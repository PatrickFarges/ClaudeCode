# ClaudeCraft

Jeu voxel type Minecraft en GDScript avec Godot 4.5+, style pastel.

## Lancer

1. Ouvrir le projet dans Godot 4.5+
2. Ouvrir `scenes/main.tscn`
3. F5 pour lancer

**Config Godot :** Physics JoltPhysics3D, résolution 1920x1080 fullscreen, cible 60 FPS.

## Architecture GDScript (`scripts/`)

- **`game_config.gd`** : configuration centrale (`class_name GameConfig`, mais tous les scripts utilisent `const GC = preload()` au lieu du class_name pour éviter les problèmes de cache Godot). Constante `ACTIVE_PACK` (actuellement "Faithful64x64"). Fonctions statiques `get_block_texture_path()`, `get_item_texture_path()`, `get_entity_texture_path()`. **Système d'aliases textures** : `TEXTURE_ALIASES` dict + `resolve_block_texture(tex_name)` — résout les noms manquants entre packs (ex: `cactus_side` → `cactus_bottom`, `sandstone_side` → `sandstone`, `jungle_leaves` → `oak_leaves`, etc. 8 aliases)
- **`block_registry.gd`** : registre centralisé des types de blocs (65 types, enum 0-64). **Blocs originaux (0-24)** : AIR, GRASS, DIRT, STONE, SAND, WOOD, LEAVES, SNOW, CACTUS, DARK_GRASS, GRAVEL, PLANKS, CRAFTING_TABLE, BRICK, SANDSTONE, WATER, COAL_ORE, IRON_ORE, GOLD_ORE, IRON_INGOT, GOLD_INGOT, FURNACE, STONE_TABLE, IRON_TABLE, GOLD_TABLE. **Variantes de pierre (25-31)** : COBBLESTONE, MOSSY_COBBLESTONE, ANDESITE, GRANITE, DIORITE, DEEPSLATE, SMOOTH_STONE. **Bois par essence (32-43)** : SPRUCE/BIRCH/JUNGLE/ACACIA/DARK_OAK/CHERRY _LOG et _PLANKS. **Feuillages (44-49)** : SPRUCE/BIRCH/JUNGLE/ACACIA/DARK_OAK/CHERRY _LEAVES. **Minerais (50-51)** : DIAMOND_ORE, COPPER_ORE. **Raffinés (52-55)** : DIAMOND_BLOCK, COPPER_BLOCK, COPPER_INGOT, COAL_BLOCK. **Naturels (56-60)** : CLAY, PODZOL, ICE, PACKED_ICE, MOSS_BLOCK. **Fonctionnels (61-64)** : GLASS, BOOKSHELF, HAY_BLOCK, BARREL. Chaque bloc a couleur pastel, dureté, textures par face. `is_workstation()` (const `WORKSTATION_BLOCKS` Dictionary avec BARREL). `get_block_tint()` retourne des tints par feuillage (cerisier rose, bouleau jaune-vert, etc.)
- **`chunk.gd`** : portion du monde (16×16×256 blocs), greedy meshing (faces visibles uniquement), Ambient Occlusion, variation luminosité par face, collision ConcavePolygon. **UV corrigés** : V inversé dans `_emit_quad()` pour que le haut des textures corresponde au haut des blocs (herbe en haut de grass_block_side)
- **`chunk_generator.gd`** : génération procédurale threadée (4 workers max, Mutex), 6 noises Simplex/Perlin (terrain, élévation, température, humidité, cavernes, stone_var). **Arbres par biome** : forêt=chêne+30% chêne noir, plaines=bouleau (BIRCH_LOG/LEAVES), montagne=sapin (SPRUCE_LOG/LEAVES), désert=cactus (~0.7%, hauteur 1-3) + acacia (~2.5%). **Passe 1.5 souterraine** : DEEPSLATE sous y<16, veines d'ANDESITE/GRANITE/DIORITE (noise ranges), DIAMOND_ORE (y<16, rare), COPPER_ORE (y<50, commun). **Passe 1.7** : MOSS_BLOCK sur murs de grottes. **Passe 3** : ICE sur eau en montagne, CLAY près de l'eau, PODZOL en forêt dense (~15%). **Passe 4 structures** : applique les structures prédéfinies via `_apply_structures()` (test AABB + patch blocs)
- **`structure_manager.gd`** : Autoload — chargement des structures JSON depuis `res://structures/`, décompression RLE, résolution palette → BlockType, fournit `get_placement_data()` (snapshot thread-safe) au chunk_generator. Placements lus depuis `user://structures_placement.json` ou `res://structures/placements.json`
- **`world_manager.gd`** : orchestration chargement/déchargement chunks, `render_distance=4`, max 2 meshes/frame, hysteresis de déchargement, spawn mobs passifs (**60% par chunk, 2-4 mobs, max 100**) et PNJ villageois (5% par chunk, max 20). **Spawn biome-spécifique** : désert=poulet/cheval, neige=loup, forêt=cochon/loup/mouton/vache, plaines=les 6 types. Spawn sur GRASS, DARK_GRASS, SAND, SNOW. Connecte StructureManager au ChunkGenerator au démarrage. **POI Manager** : instancie `POIManagerScript` pour tracker les workstations, scan des chunks au chargement (range y_min→y_max), cleanup au déchargement. **Professions** : assigne une profession déterministe par hash (`(hash_val * 7 + 3) % 9`) et le modèle GLB correspondant via `VProfession.get_model_for_profession()`. Passe `poi_manager` aux NPCs. Libère les POI claimés quand les NPCs sont despawn
- **`villager_profession.gd`** : données statiques des professions et emploi du temps. **Enum Profession** (9 valeurs) : NONE, BUCHERON, MENUISIER, FORGERON, BATISSEUR, FERMIER, BOULANGER, CHAMAN, MINEUR. **Enum Activity** (5 valeurs) : WANDER, WORK, GATHER, GO_HOME, SLEEP. **PROFESSION_DATA** : mapping profession → workstation BlockType (constantes entières locales BT_CRAFTING_TABLE=12, BT_FURNACE=21, BT_STONE_TABLE=22, BT_IRON_TABLE=23, BT_GOLD_TABLE=24, BT_BARREL=64), 2 modèles GLB par profession (répartis dans les 18 character-a→r), animation de travail, noms FR/EN. **SCHEDULE** : 8 plages horaires (0-6 SLEEP, 6-8 WANDER, 8-12 WORK, 12-14 GATHER, 14-17 WORK, 17-19 GATHER, 19-20 GO_HOME, 20-24 SLEEP). Fonctions statiques : `get_activity_for_hour()`, `get_workstation_block()`, `get_model_for_profession()`, `get_profession_name()`, `get_work_anim()`
- **`poi_manager.gd`** : gestionnaire de Points of Interest (workstations). **`poi_registry`** : Dictionary Vector3i → {block_type, claimed_by, chunk_pos}. **`WORKSTATION_TYPES`** : const Dictionary {12,21,22,23,24,64} pour lookup O(1) (inclut BARREL). `scan_chunk(chunk_pos, packed_blocks, y_min, y_max)` : scan limité au range vertical utile. `find_nearest_unclaimed(profession, world_pos)` : cherche le POI libre le plus proche pour la profession. `claim_poi()` / `release_poi()` : système de réservation (1 villageois = 1 POI). `remove_chunk_pois()` : cleanup au déchargement de chunk. Utilise `preload()` pour VillagerProfession et constantes locales CHUNK_SIZE/HEIGHT (évite dépendances class_name)
- **`npc_villager.gd`** : PNJ humanoïdes avec professions et emploi du temps. Utilise les 18 modèles GLB BlockPNJ (Kenney.nl, `character-a` à `character-r`), 2 modèles par profession. **Système de professions** : `var profession: int`, assigné au spawn par WorldManager, détermine le modèle GLB et le workstation cible. **Emploi du temps** : vérifie le schedule toutes les 2s via `_day_night.get_hour()`, dispatche vers 5 comportements : `_behavior_wander` (errance classique), `_behavior_sleep` (immobile la nuit), `_behavior_gather` (errance dans un rayon de 15 blocs autour de home), `_behavior_go_home` (marche vers spawn), `_behavior_work` (claim POI → marche vers workstation → animation de travail). **Navigation** : `_walk_toward(target, delta)` avec détour perpendiculaire anti-stuck (2s de blocage → déviation 2s). **POI** : `claimed_poi: Vector3i`, claim/release via `poi_manager`. **Mouvement commun** : `_apply_movement(delta)` factorisé (auto-jump, évitement eau/falaises, stuck detection). **Animations GLB** : 27 animations embarquées par modèle, loop forcé, transition walk↔idle↔attack selon état. `get_info_text()` retourne "Forgeron - Au travail" etc. **Combat** : `health=20`, `take_hit(damage, knockback)` avec release POI à la mort, groupe "npc_villagers" pour détection flèches
- **`bedrock_entity.gd`** : parseur Minecraft Bedrock `.geo.json` → hiérarchie Godot Node3D. Parse la structure des bones, construit des cubes UV-mappés avec textures Bedrock. **Distinction clé (confirmée par docs Microsoft + Blockbench #990)** : `bind_pose_rotation` (rotation mesh uniquement, bakée dans les vertices, **NE propage PAS** aux enfants — les enfants sont en espace pré-rotation) vs `rotation` (rotation du bone node, propage aux enfants via scene tree). **Convention de rotation** : Bedrock utilise la convention inverse de Godot → angles `bind_pose_rotation` négués avant application (`-deg_to_rad()`), ce qui aligne précisément le bas du corps avec le haut des pattes (gap zéro). **Hiérarchie parent-child** : conservée telle que déclarée dans le .geo.json (pattes = enfants du body), offset = `(child_pivot - parent_pivot) * SCALE` transformé par la rotation node du parent uniquement. Supporte format 1.8.0 et 1.12.0+, héritage de géométrie (mouton laineux), inflate, mirror, cube-level rotation, skip_bones (filtrage équipement cheval). Cache géométrie static var. `SCALE = 1/16`. Material : `CULL_DISABLED` + `TRANSPARENCY_DISABLED` + `TEXTURE_FILTER_NEAREST`
- **`passive_mob.gd`** : mobs animaux avec modèles Bedrock .geo.json. **6 types** : SHEEP, COW, CHICKEN, PIG, WOLF, HORSE — enum `MobType`, données dans `MOB_DATA` (collision_size, geo_path, geo_id, texture, health, meat_name, meat_count, bone_map, skip_bones). **Modèles Bedrock** via `BedrockEntity.build_model()` : hiérarchie de Node3D avec bones nommés, cubes UV-mappés depuis textures .png/.tga. **Animation MC-authentique** (formules extraites du source MC 1.12 `ModelQuadruped.setRotationAngles()`) : `_limb_swing` (compteur distance continu) + `_limb_swing_amount` (0..1, lissé). **Pattes** : `cos(limbSwing × 0.6662) × 1.4 × limbSwingAmount` — fréquence 0.6662 rad/unité (~9.4 ticks/cycle), amplitude 1.4 rad (≈80°), paires diagonales en opposition π. **Ailes poulet** : basées sur `_age_ticks` (temps, pas distance), amplitude variable selon vitesse (20° idle → 45° course). **Queue loup** : même formule que pattes sur axe Y. **Queue cheval** : balancement temporel doux. **Idle** : lerp retour au bind pose, look-around tête (yaw ±15°, pitch ±5°), respiration body scale ±1%. Bind rotations sauvegardées au setup. **Combat** : `take_hit(damage, knockback)` avec flash rouge 0.3s, mort → `_drop_loot()` (heal joueur direct + Label3D flottant vert "+N Viande"). **Spawn** : `add_to_group("passive_mobs")` pour détection flèches. **Direction face** : `atan2(-dir.x, -dir.z)` car modèles Bedrock orientés -Z
- **`arrow_entity.gd`** : projectile flèche tiré par l'arc. **Physique MC-like** : gravité 20 m/s², air drag 0.99/frame, spawn 0.8m devant la caméra (évite auto-collision), exclusion RID du tireur pendant 0.2s. **Dégâts** : `base_damage=6.0`, critique si charge complète (bonus aléatoire), knockback 8.0 + lift 3.0. **Collision** : raycast PhysicsRayQueryParameters3D chaque frame, + scan groupe "passive_mobs"/"npc_villagers" (rayon 1.2m). **Visuel** : mesh extrudé depuis texture `arrow.png` (2 quads croisés, scale 1.5), trail particles (jaune si critique, gris sinon), particules d'impact bloc (marron) et entité (rouge sang), Label3D flottant chiffre de dégâts (tween rise + fade). **Durée de vie** : 30s en vol, 60s planté dans un bloc
- **`player.gd`** : contrôle FPS (CharacterBody3D), minage progressif (basé sur hardness × `BASE_MINING_TIME`, accéléré par les outils), placement de blocs (vérif AABB chevauchement), inventaire 9 slots hotbar + slots outils parallèles (`hotbar_tool_slots`) + slots nourriture parallèles (`hotbar_food_slots`), intégration HandItemRenderer pour le bras FPS. **`BASE_MINING_TIME = 5.0`** : multiplicateur global, temps = dureté × 5.0 / mult_outil. **Gestion hotbar** : `assign_hotbar_slot()` remplace le bloc ET efface l'outil/nourriture du slot. Touches 1-9 autorisées quand inventaire ouvert. **Hotbar par défaut** : 3 blocs + 4 haches (bois/pierre/fer/diamant) + pioche diamant + arc. **Système de nourriture** : maintenir clic droit pour manger (2s), particules rouges, restaure 4 PV. **Système d'arc** : `_handle_bow(delta)` exécuté AVANT `_handle_block_interaction()` (critique : le raycast retourne tôt quand on vise le ciel). Maintenir clic droit = charger (`is_drawing_bow`, `bow_charge_time` jusqu'à `BOW_MAX_CHARGE=1.0`), relâcher = tirer `_fire_arrow()`. Formule MC : `factor = (f² + 2f) / 3` où f = charge/max. Annulation auto sur changement slot/mort/UI. `_update_hand_display()` utilise `hand_renderer.update_held_item_sprite(tool_type)` pour les outils (extrusion 3D pixel par pixel)
- **`hand_item_renderer.gd`** : rendu du bras et de l'item en main (vue FPS). Attaché comme enfant de Camera3D. Bras BoxMesh couleur peau masqué quand un item est tenu. **Trois chemins de rendu** : `update_held_item(BlockType)` pour les blocs (cube texturé par face depuis le pack actif), `update_held_item_sprite(ToolType)` pour les outils (**extrusion 3D pixel par pixel** — chaque pixel opaque de la texture 16x16 est un petit cube avec faces avant, arrière et bords, regroupés par couleur unique pour optimiser les surfaces ; épaisseur 0.04 unités, taille 0.38), `update_held_tool_node(Node3D)` pour les modèles 3D arbitraires (food GLB). **Position MC-style** : BASE_POSITION (0.56, -0.52, -0.72) calqué sur `ItemRenderer.transformSideFirstPerson`. **Position outils** : rotation (0, -10, 40) degrés — diagonale MC, manche bas-droite. **Position blocs** : rotation (0, 45, 0) — rotation Y 45° comme `block/block.json` MC. **Bobbing** : balancement avant/arrière (rotation X ±12°, ±20° au sprint), état lissé via `_smooth_pos`/`_smooth_rot_x`. **Swing MC sinusoïdal** : `swing_progress` 0→1 en 0.28s, rotation calculée par `_compute_swing_rotation()` (outils: arc X -60° + Y -15° + Z -15° via sin/sqrt, blocs: X -40°) + déplacement `_compute_swing_position()` (X -0.2, Y ±0.1, Z -0.1 sinusoïdaux). Formules tirées de `ItemRenderer.transformFirstPerson()` MC 1.12. **Rendu arc** : `start_bow_pull()`, `update_bow_pull(pull)`, `stop_bow_pull()` — swap texture bow.png → bow_pulling_0/1/2 selon seuils MC (0.65, 0.9), rebuild mesh extrudé à chaque changement. `_holding_tool` flag mis à jour automatiquement. Cache de matériaux par texture+tint. Utilise `const GC = preload("res://scripts/game_config.gd")`
- **`item_model_loader.gd`** : [DEPRECATED — plus utilisé par le pipeline d'outils] Parseur Minecraft JSON model (Blockbench) → ArrayMesh Godot. Conservé pour compatibilité future
- **`tool_registry.gd`** : registre des outils (enum `ToolType` : NONE, STONE_AXE, STONE_PICKAXE, STONE_SHOVEL, STONE_HOE, STONE_HAMMER, STONE_SWORD, IRON_PICKAXE, IRON_SWORD, DIAMOND_AXE, DIAMOND_PICKAXE, DIAMOND_SWORD, NETHERITE_SWORD, BOW, SHIELD, **WOOD_AXE, WOOD_PICKAXE, IRON_AXE**). **Système de tiers** : `TIER_WOOD=1.667`, `TIER_STONE=2.0`, `TIER_IRON=2.5`, `TIER_DIAMOND=3.333`, `TIER_NETHER=4.0` — constantes facilement modifiables, remplissent automatiquement les `mining_speed` via `_ensure_speeds()`. **PICK_BOOST=2.0** : pioches minent 2× plus vite que les haches sur leurs blocs spécialisés. **CROSS_TOOL_MULT=1.3** : tout outil donne 1.3× sur les blocs non-spécialisés (mieux que mains nues). **Listes de blocs par type d'outil** : `AXE_BLOCKS` (17 bois), `PICK_BLOCKS` (16 pierres/minerais), `SHOVEL_BLOCKS` (9 terres), `HOE_BLOCKS` (8 feuilles) — ajout/suppression simple. Chaque outil a un `item_texture` (nom du PNG dans le pack actif `textures/item/`), une durabilité et optionnellement `_tier`/`_type` pour le remplissage auto. **Rendu 3D extrudé** via `hand_item_renderer._build_extruded_mesh()`. `get_item_texture_path(tool_type)` retourne le chemin complet via `const GC = preload()`. Shield utilise `entity/shield_base_nopattern.png` (cas spécial)
- **`craft_registry.gd`** : ~61 recettes craft réparties en 6 catégories. **Hand (tier 0)** : planches (7 recettes, 1 par essence de bois). **Furnace** : cuisson (pierre lisse, verre, lingots cuivre, diamant, brique). **Wood Table (tier 1)** : pavé, mousse, foin, bibliothèque, tonneau, blocs de charbon/cuivre, verre lot. **Stone Table (tier 2)** : andésite, granite, diorite, glace compactée, pierre lisse lot, deepslate. **Iron Table (tier 3)** : productions en masse. **Gold Table (tier 4)** : productions maximales
- **`audio_manager.gd`** : pool 8 AudioStreamPlayer2D + 6 3D, sons ambiants par biome avec crossfade. **Chargement null-safe** : `_safe_load()` et `_safe_load_bank()` filtrent les fichiers manquants avec warning. **Sons couvrent les 65 types de blocs** : pierre (17 variantes + minerais), bois (17 variantes + essences), terre/argile/podzol/mousse, métal (cuivre/diamant/charbon), feuilles (7 essences + foin), neige/glace. **Son manger** : `play_eat_sound()` joue `Audio/eating-effect-254996.mp3` avec pitch aléatoire. **Ambiance Forest par heure** : `forest_ambient_by_hour` mappe 7 plages horaires vers 11 fichiers MP3 réels (`Audio/Forest/`), remplaçant l'ambiance procédurale pour le biome Forêt. Détection de l'heure via `day_night_cycle.get_hour()`, crossfade automatique au changement de plage horaire. Les autres biomes gardent l'ambiance procédurale. **Note** : les fichiers `.import` sont gitignorés (`*.import`), un `--headless --import` dans Godot est nécessaire après un clone frais
- **`locale.gd`** : traductions FR/EN — 65 noms de blocs, ~61 noms de recettes, labels UI inventaire (7 onglets) et crafting
- **`texture_manager.gd`** : gestionnaire de Texture2DArray (80 layers, indices 0-79). Utilise `const GC = preload("res://scripts/game_config.gd")` et `GC.resolve_block_texture()` pour charger les PNG avec fallback aliases. **Auto-détection de résolution** : détecte la taille des textures (16x16, 32x32, 64x64...) depuis la première image trouvée, redimensionne toutes les textures à cette résolution. **`_force_opaque()`** : force alpha=1.0 sur les textures non-verre pour éviter les trous de transparence (cactus notamment). Affiche le pack actif et la résolution détectée au démarrage. Couvre toutes les variantes : 6 essences de bois, 7 types de feuilles, 7 variantes de pierre, minerais, naturels, décoratifs
- **`hotbar_ui.gd`** : barre d'outils en bas de l'écran (9 slots). Affiche les **textures réelles** des blocs et outils dans chaque slot via TextureRect (fallback ColorRect si texture introuvable). Les blocs montrent leur face "top" avec tint, les outils montrent leur sprite d'item. Cache d'icônes pour éviter les rechargements
- **`inventory_ui.gd`** : inventaire avec 7 onglets (TOUT, Terrain, Bois, Pierre, Minerais, Déco, Stations), grille 8 colonnes, tri par rareté. **Clic gauche ET droit** sur un bloc assigne au slot hotbar actif. Panneau 780px avec scroll. Affiche les textures réelles des blocs (TextureRect avec tint, fallback ColorRect)

## Biomes

**4 biomes procéduraux :** Désert (temp>0.65, humid<0.35), Forêt (temp 0.45-0.7, humid>0.55), Montagne (temp<0.35), Plaines (défaut)

## Scène principale (`scenes/main.tscn`)

WorldManager + Player (spawn à y=80) + WorldEnvironment (SSAO, ciel pastel) + DirectionalLight3D + UI layers (Hotbar, Crosshair, Inventory, Crafting, VersionHUD, AudioManager)

## Système de structures prédéfinies (`structures/`)

Permet de placer des constructions (villages, tours, cabanes...) n'importe où dans le monde généré. Les structures sont appliquées pendant la génération des chunks (passe 4), donc zéro coût en rendu.

- **Format structure JSON :** palette de noms de blocs + données RLE en ordre layer-first (`index = y * sx * sz + z * sx + x`). Bloc spécial `KEEP` (valeur 255) = ne pas toucher le terrain. `AIR` = creuser.
- **`structures/placements.json`** : liste de `{"structure": "nom", "position": [x, y, z]}` indiquant où placer chaque structure en coordonnées monde
- **`scripts/convert_schem.py`** (~940 lignes) : convertisseur `.schem` (Sponge Schematic v2/v3) → JSON ClaudeCraft. Parseur NBT maison (zéro dépendance), décodage varint, mapping intelligent Minecraft→ClaudeCraft (260+ blocs explicites incluant les 6 essences de bois, 7 variantes de pierre, minerais cuivre/diamant, + ~60 règles par pattern pour escaliers, dalles, laines, végétation...). Usage : `python scripts/convert_schem.py fichier.schem [--info] [--output chemin.json]`
- **Pipeline** : asset `.schem` → `convert_schem.py` → `structures/nom.json` → ajouter dans `placements.json` → apparaît automatiquement dans le monde

## Structure Viewer (`scripts/structure_viewer.py`, ~1920 lignes)

Application desktop PyQt6/PyOpenGL de visualisation 3D de structures voxel et de modèles 3D (GLB/OBJ). Zéro dépendance supplémentaire pour le parsing GLB/OBJ (parseurs maison avec numpy).

```bash
pip install PyQt6 PyOpenGL numpy
python scripts/structure_viewer.py
python scripts/structure_viewer.py "assets/Weapon/GLB/diamond_axe_minecraft.glb"
```

- **Formats voxel** : `.json` (ClaudeCraft), `.schem` (Sponge Schematic), `.litematic` (Litematica) — rendu face-culled avec couleurs pastel ClaudeCraft
- **Formats mesh** : `.glb` (glTF Binary), `.obj` (Wavefront OBJ) — rendu triangle avec éclairage directionnel simulé
- **Parseur GLB maison** (~180 lignes) : header 12 octets + chunks JSON/BIN, `_read_accessor()` numpy (FLOAT/UINT/UBYTE avec stride), traversée récursive des nœuds avec accumulation des transforms 4x4 (quaternion→matrice), couleur par submesh : COLOR_0 > baseColorFactor > KHR_materials_pbrSpecularGlossiness > gris défaut
- **Parseur OBJ** (~70 lignes) : vertex colors Kenney (`v x y z r g b`), lecture `.mtl` pour couleur Kd, triangulation fan, fallback encodage UTF-8→Latin-1→CP1252
- **Classes données** : `SubMesh` (positions/normals/indices numpy + couleur), `MeshData` (bbox, centre, dimensions, `origin_analysis()` : centre/bas-centre/coin/décalé)
- **Rendu mesh OpenGL** : 2 display lists (filled + wireframe), `glDisable(GL_CULL_FACE)` pour meshes double-sided, wireframe overlay avec `GL_POLYGON_OFFSET_LINE`
- **Grille mesh** : centrée sur l'origine (pas sur le mesh), espacement adaptatif (0.1/0.5/1/5/10 selon la taille)
- **File browser** : navigateur de fichiers intégré, icône rose (`#f38ba8`) pour meshes vs bleu (`#89b4fa`) pour voxels
- **Panneau info mesh** : dimensions, bbox min/max, centre, analyse d'origine, vertices/triangles, sous-objets avec couleurs
- **Contrôles** : clic droit=rotation, clic gauche=pan X/Y, Ctrl+clic gauche=pan Z, molette=zoom, R=reset, F=face, T=dessus, W=wireframe, I=infos, Ctrl+O=ouvrir, Ctrl+S=exporter JSON (voxel uniquement)
- **Config persistante** : `~/.claudecraft_viewer_config.json` (dernier répertoire)

## Système de packs de textures (`TexturesPack/`)

Le jeu supporte plusieurs packs de textures Minecraft-compatibles. Changer `ACTIVE_PACK` dans `game_config.gd` pour switcher. Résolution auto-détectée (16x16, 32x32, 64x64...).
- `TexturesPack/Faithful64x64/` : **pack actif** (~3520 PNG, 64x64), structure `assets/minecraft/textures/{block,item,entity}/`. Les textures **block/** sont utilisées pour le monde et les cubes en main, les textures **item/** pour les outils/armes en main (extrusion 3D) et dans la hotbar
- `TexturesPack/Aurore Stone/` : pack alternatif (~3520 PNG, 16x16), même structure. Switcher via `ACTIVE_PACK` dans `game_config.gd`

## Assets

`Audio/` (~334 fichiers OGG/MP3, dont `Audio/Forest/` 11 MP3 d'ambiance par heure du jour), `BlockPNJ/` et `MiniPNJ/` (modèles 3D FBX/GLB/OBJ, personnages Kenney.nl), `NPC/` (dossier PNJ), `assets/Mobs/Passive/` (6 GLB Sketchfab : minecraft_-_sheep/cow/chicken/wolf/horse.glb + minecraft_pig.glb — meshes statiques sans squelette), `assets/Lobbys/` (assets Minecraft .schem/.mca à convertir), `assets/Weapon/` [LEGACY — plus utilisé par le système d'outils, conservé pour référence] (modèles JSON Blockbench + GLB Sketchfab), `assets/Deco/` (apple.glb pour la nourriture)

## Pipeline de données Minecraft (`scripts/minecraft_import.py`, ~700 lignes)

Extracteur complet qui parse le `client.jar` Java Edition 1.21.11 (`D:\Games\Minecraft - 1.21.11\client.jar`) et les assets Bedrock Edition (`D:\Games\Minecraft - Bedrock Edition\data\`), puis génère 8 fichiers JSON consolidés dans `minecraft_data/`.

```bash
python scripts/minecraft_import.py
```

| Fichier de sortie | Contenu | Volume |
|-------------------|---------|--------|
| `minecraft_blocks.json` | Modèles de blocs : nom, type (cube_all/cube_column/stairs/slab/...), parent, textures résolues, disponibilité TexturesPack | 2 390 blocs (2 144 avec textures) |
| `minecraft_items.json` | Modèles d'items : nom, type (flat/block/handheld), parent, textures | 1 283 items |
| `minecraft_recipes.json` | Recettes (crafting_shaped, crafting_shapeless, smelting, blasting, smoking, campfire_cooking, stonecutting), tags résolus | 1 396 recettes |
| `minecraft_blockstates.json` | Mapping état → modèle (orientation, allumé/éteint, ouvert/fermé...) | 1 168 blockstates |
| `minecraft_textures.json` | Inventaire de toutes les textures MC, catégorisées (block/item/entity), avec flag `in_texturepack` | 2 518 textures (2 516 dispo) |
| `minecraft_entities_bedrock.json` | Modèles d'entités 3D Bedrock (.geo.json) : bones, géométrie, texture dimensions | 113 entités |
| `minecraft_animations_bedrock.json` | Animations d'entités Bedrock : walk, idle, attack, etc. avec durée et loop | 325 animations (83 fichiers) |
| `minecraft_tags.json` | Tags/groupes d'items et blocs (#minecraft:planks, #minecraft:logs, #minecraft:stone_tool_materials...) | 402 tags |

**Classification des blocs par template parent :**
- `cube_all` (283) : un cube, même texture sur 6 faces — stone, diamond_block, gold_block...
- `cube_column` (89) : texture top/bottom + side — oak_log, quartz_pillar...
- `cube_bottom_top` (27) : texture top + bottom + side — grass_block, sandstone...
- `orientable` (48) : texture front + side + top — furnace, dispenser, dropper...
- `stairs` (162), `slab` (116), `wall` (119), `fence` (90), `door` (157), `cross` (118 = fleurs/herbes)...

**Sources de données Minecraft locales :**
- Java Edition 1.21.11 : `D:\Games\Minecraft - 1.21.11\client.jar` (31 Mo, extrait vers `minecraft_data/client_jar/`)
- Bedrock Edition : `D:\Games\Minecraft - Bedrock Edition\data\resource_packs\vanilla\` (modèles entités, animations, textures)
- TexturesPack : `TexturesPack/Aurore Stone/assets/minecraft/textures/` (1114 block, 792 item, 615 entity PNG)
- **MC 1.12 Source (MCP940)** : `D:\Projets\Source code of minecraft 1.12\mcp940-master\mcp940-master\` — code Java décompilé (rendu FPS, modèles, transforms) + 878 block models + 717 item models + 500 textures 16x16. Utilisé comme référence pour le positionnement first-person (`ItemRenderer.java`, `handheld.json`, `block/block.json`)

**Note importante :** `minecraft_data/` est dans `.gitignore` (trop volumineux). Régénérable à tout moment via `python scripts/minecraft_import.py`.

**Documentation embarquée :** `ARCHITECTURE.md`, `QUICKSTART.md`, `BIOMES.md`, `MOVEMENT.md`, `MULTITHREADING.md`, `PERFORMANCE.md`

## Direction du projet — "The Settlers"

**Vision :** ClaudeCraft évolue d'un Minecraft-like vers un jeu de gestion/colonie inspiré de **The Settlers** (chaînes de production, villageois autonomes, construction, économie). Minecraft sert de base pour la simplicité du rendu voxel et l'immense catalogue de blocs/items/recettes réutilisables sans effort de design.

**Phase 1 (fait) :** Monde voxel, biomes, minage, craft, outils, nourriture
**Phase 2 (fait) :** Professions villageoises (9 métiers), emploi du temps jour/nuit, POI workstations, navigation vers cibles
**Phase 3a (fait) :** Premier import Minecraft — 65 blocs (25→65), 80 textures (30→80), ~61 recettes (30→61), bois par biome (6 essences), minerais souterrains (diamant, cuivre), variantes de pierre (7 types), blocs naturels (argile, glace, podzol, mousse), tints feuillages par essence, BARREL workstation
**Phase 3a.1 (fait) :** Refonte du système de textures et outils — `GameConfig` centralisé (preload, aliases textures cross-pack), pack Faithful64x64 actif, auto-détection résolution, outils 3D extrudés pixel par pixel (Minecraft-style, épaisseur visible), UV blocs corrigés, textures réelles dans hotbar et inventaire. **Positionnement et swing MC-authentiques** (référence : source MCP940/MC 1.12 décompilé) : BASE_POSITION (0.62,-0.42,-0.68) validé visuellement, rotation outils (0,-10,40) et blocs (0,45,0) calquées sur `handheld.json`/`block.json`, swing sinusoïdal multi-axes calqué sur `transformFirstPerson` (sin/sqrt curves). **Système de tiers de minage** : `BASE_MINING_TIME=5.0` (player.gd) × dureté/multiplicateur, 5 tiers (bois=1.667, pierre=2.0, fer=2.5, diamant=3.333, netherite=4.0), 3 nouveaux outils (WOOD_AXE, WOOD_PICKAXE, IRON_AXE). **Audio corrigé** : `.import` régénérés, chargement null-safe, sons couvrant les 65 blocs
**Phase 3a.2 (fait) :** Combat et mobs — **Arc/flèches** (charge MC, physique gravité+drag, particules trail/impact, dégâts flottants Label3D). **6 types de mobs passifs** avec modèles Bedrock .geo.json (mouton, vache, poulet, cochon, loup, cheval), parseur `bedrock_entity.gd` (cubes UV-mappés, hiérarchie bones parent-child, bind_pose_rotation bakée en vertices avec convention négée pour alignement corps-pattes zéro gap). **Animation MC-authentique** (source MC 1.12 `ModelQuadruped`) : `cos(limbSwing × 0.6662) × 1.4 × limbSwingAmount`, paires diagonales, _limb_swing/_limb_swing_amount lissés, ailes poulet temporelles, queue loup/cheval. **Loot viande** sur mort (heal joueur + label flottant). **Monde peuplé** : spawn 60%/chunk, 2-4 mobs, max 100, types par biome. **Pioches 2× plus rapides** (PICK_BOOST), **cross-tool 1.3×** (tout outil sur tout bloc). **Cactus** densité réduite (~0.7%), acacia augmenté (~2.5%). **NPC combat** : health 20, take_hit avec release POI
**Phase 3a.3 (fait) :** Correction animation de marche des mobs — `limbSwingAmount` calé sur la formule MC complète (`speed_per_tick * 4.0`, smoothing `0.4/tick`), `limbSwing` accumulé par `limbSwingAmount * 20/sec`. Résultat : amplitude ≈24° et cycle ≈1.6s à vitesse de marche (au lieu de 80° aberrant).
**Phase 3b (à venir) :** Import étendu (centaines de blocs), chaînes de production, bâtiments fonctionnels
**Phase 4 (à venir) :** Transport de ressources, économie villageoise, construction automatique

**Données Minecraft disponibles :** 2390 blocs, 1283 items, 1396 recettes, 113 entités 3D, 325 animations — tout extrait et prêt à l'emploi dans `minecraft_data/`.

## Prochain chantier — Éditeur de structures

**Objectif :** Application desktop (Python/Tkinter ou PyQt) pour charger, convertir, visualiser en 3D et modifier des assets de structures pour ClaudeCraft.

**Workflow prévu :**
1. **Charger** un asset Minecraft `.schem` OU un asset ClaudeCraft `.json` déjà converti
2. **Convertir** automatiquement le `.schem` → format JSON ClaudeCraft (via le moteur de `convert_schem.py`)
3. **Visualiser en 3D** la structure sous tous les angles (rotation, zoom, pan) — rendu voxel des blocs avec les couleurs pastel ClaudeCraft
4. **Modifier** la structure : ajouter/supprimer des cubes individuels, déplacer des éléments (arbres, etc.), changer le type de bloc
5. **Enregistrer** l'asset modifié au format JSON ClaudeCraft dans `structures/`

**Contexte existant :**
- `scripts/convert_schem.py` (~940 lignes) : parseur NBT + convertisseur .schem → JSON, à réutiliser comme moteur de conversion
- `scripts/block_registry.gd` : référence des types de blocs et couleurs pastel (à porter en Python pour le rendu)
- `structures/` : dossier cible pour les assets finaux
- `assets/Lobbys/` : assets Minecraft source de test (Natural Lobby 203x104x203, Factions Spawn 203x256x203)
- Structures de taille variable : de petites cabanes (5x12x5) à de grands villages (200x250x200)
